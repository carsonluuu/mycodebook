### 基本操作

_**1 **_**左移操作 a &lt;&lt; b**

将A的二进制表示的每一位向左移B位，左边超出的位截掉，右边不足的位补0

A = 1100  B = 2  
A &lt;&lt; B = 110000

`a << b = a * (2^b)`

_**2 **_**右移操作 A &gt;&gt; B , A &gt;&gt;&gt; B**

右移操作分为算数右移和逻辑右移

**算术右移是带符号的右移，逻辑右移是不带符号的右移**。  
算术右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数。  
逻辑右移：将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。

C语言：只有逻辑右移 A &gt;&gt; B

JAVA 和 Python中：算术右移 A &gt;&gt; B , 逻辑右移 A &gt;&gt;&gt; B

A = 11111111111111111111111110000001  
B = 2  
A &gt;&gt; B = 11111111111111111111111111100000  
A &gt;&gt;&gt; B = 00111111111111111111111111100000

`a >> b = a / (2^b)`

_**3 **_**按位与操作 a & b**

将A和B的二进制表示的每一位进行与操作，只有两个对应的二进制位都为1时，结果位才为1，否则为0.

A = 001010  
B = 101100  
A & B = 001000

_**4 **_**按位或操作 a \| b**

将A和B的二进制表示的每一位进行或操作，只要两个对应的二进制位有一个为1，结果位就为1，否则为0.

A = 001010  
B = 101100  
A \| B = 101110

_**5 **_**按位非操作 ~ a**

将A的二进制表示每一位进行取反操作，如果对应的二进制位为0，结果位为1，否则为0.

 A = 00000000000000000000000000001010  
~A = 11111111111111111111111111110101

so if you want to get a negative number, you can simply do ~x + 1

_**6 **_**按位异或操作 a ^ b**

将A和B的二进制表示的每一位进行异或操作，如果对应的二进制位不同，结果位为1，否则为0.

A = 001010  
B = 101100  
A ^ B = 100110

### 常用技巧

1．判断奇偶

只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用`if ((a & 1) == 0)`代替if \(a % 2 == 0\)来判断a是不是偶数。

2．交换两数

```java
void Swap(int &a, int &b) {
    if (a != b) {
        a ^= b;
        b ^= a;
        a ^= b;
    }
}
```

3. 消去x最后一位的1

**x & \(x - 1\) 用于消去x最后一位的1**

```
x = 1100
x - 1 = 1011
x & (x - 1) = 1000
```

4. Is Power of Two

N如果是2的幂次，则N满足两个条件。

   1.N &gt;0 

   2.N的二进制表示中只有一个1

因为N的二进制表示中只有一个1，所以使用N & \(N - 1\)将N唯一的一个1消去，应该返回0。

```
return n > 0 && (n & (n - 1)) == 0;
```

5. Count 1

由x & \(x - 1\)消去x最后一位的1可知。不断使用 x & \(x - 1\) 消去x最后一位的1，计算总共消去了多少次即可。

```
public int countOnes(int num) {
    int count = 0;
    while (nums != 0) {
        num = num & (num - 1);
        count++;
    }
    return count;
}
```

6. Find Single Number

**a ^ b ^ b = a**

