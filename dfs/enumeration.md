# Enumeration

也是一种依赖于DFS或者backtracking的类型，属于暴力枚举，题型本质是求笛卡尔积或者说求组合



“字符串构造式 DFS + backtracking”，还有最简单直接又好分析时间复杂度的做法，就是从 String 中每个字符的角度出发，去考虑 “拿 / 不拿”。

StringBuilder 的构造式 DFS + Backtracking，对 “加 / 不加” 的先后顺序是敏感的，下面两题中，同样的代码，都是

* 先走“不加”的分支
* 再走“加”的分支

原因在于，这个模板是 “带着当前考虑元素” 的 DFS，在当前函数尾部回溯。当两个 dfs 同处一层，而同层 dfs 只在最尾部才回溯的时候，如果先跑添加的分支，会在后面执行不添加分支时候出错。

否则就一次 dfs 后面跟着一次 sb.setLength\(\)，也可以

体会一下（subset也是能这么写，拿或者不拿）



